<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>密集爱心弹窗与满屏祝福</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Microsoft YaHei", sans-serif;
        }
        body {
            overflow: hidden;
            background-color: #000000;
            height: 100vh;
            width: 100vw;
        }
        /* 引导页样式 */
        .intro-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .intro-content {
            width: 360px;
            height: 180px;
            background: white;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .intro-text {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
        }
        .intro-btn {
            padding: 8px 32px;
            font-size: 16px;
            font-weight: bold;
            background: #A7D3FF;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .intro-btn:hover {
            background: #86C5FF;
        }
        /* 提示弹窗样式：缩小尺寸增加密度 */
        .tip-window {
            position: fixed;
            width: 120px; /* 原200px，缩小40% */
            height: 36px; /* 原50px，缩小28% */
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333;
            font-size: 14px; /* 原16px，适配小尺寸 */
            font-weight: bold;
            z-index: 999;
            transition: transform 0.03s linear;
        }
    </style>
</head>
<body>
    <!-- 引导页 -->
    <div class="intro-modal" id="introModal">
        <div class="intro-content">
            <div class="intro-text">请接受我的祝福</div>
            <button class="intro-btn" id="startBtn">好</button>
        </div>
    </div>

    <script>
        // 核心配置：重点调整密集相关参数
        const CONFIG = {
            MESSAGES: [
                "早点休息", "天冷了，多穿衣服", "多喝水哦~", "保持好心情", 
                "期待下一次见面", "愿所有烦恼都消失", "我想你了", "别熬夜", 
                "好好爱自己", "顺顺利利", "今天过得开心嘛", "保持微笑呀", "记得吃水果","250"
            ],
            HEART_COUNT: 200,       // 原38个，增加110%，提升顶点密度
            POP_INTERVAL_MS: 40,   // 原80ms，缩短50%，弹窗显示更快
            EXPLODE_COUNT: 350,    // 满屏弹窗同步增加密度
            EXPLODE_INTERVAL_MS: 20,// 满屏弹窗显示更快
            GATHER_STEPS: 24,      // 收拢动画步数不变，保持流畅
            GATHER_INTERVAL_MS: 30,
            JITTER_RANGE: 8,       // 原14，缩小43%，减少位置偏移避免分散
            MARGIN: 4              // 原8，缩小50%，允许弹窗更贴近屏幕边缘
        };

        // 生成柔和 pastel 颜色 
        function randomPastelHex() {
            const h = Math.random();
            const l = 0.85;
            const s = 0.45;
            let r, g, b;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h * 6) % 2 - 1));
            const m = l - c / 2;
            const hueSegment = h * 6;
            
            if (hueSegment < 1) [r, g, b] = [c, x, 0];
            else if (hueSegment < 2) [r, g, b] = [x, c, 0];
            else if (hueSegment < 3) [r, g, b] = [0, c, x];
            else if (hueSegment < 4) [r, g, b] = [0, x, c];
            else if (hueSegment < 5) [r, g, b] = [x, 0, c];
            else [r, g, b] = [c, 0, x];

            r = Math.round((r + m) * 255).toString(16).padStart(2, '0');
            g = Math.round((g + m) * 255).toString(16).padStart(2, '0');
            b = Math.round((b + m) * 255).toString(16).padStart(2, '0');
            return `#${r}${g}${b}`;
        }

        // 生成更多爱心顶点（提升密度）
        function getHeartPoints(count) {
            const points = [];
            for (let i = 0; i < count; i++) {
                const t = Math.PI * 2 * i / count;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                points.push({ x, y });
            }
            // 从爱心最上方开始排序，确保分布均匀
            const minYIndex = points.findIndex(p => p.y === Math.min(...points.map(p => p.y)));
            return [...points.slice(minYIndex), ...points.slice(0, minYIndex)];
        }

        // 减少位置偏移，让弹窗更集中
        function jitter() {
            return Math.floor(Math.random() * (CONFIG.JITTER_RANGE * 2 + 1)) - CONFIG.JITTER_RANGE;
        }

        // 线性插值函数
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }

        // 创建缩小版弹窗
        function createTipWindow(x, y, color, text) {
            const div = document.createElement('div');
            div.className = 'tip-window';
            div.style.left = `${x}px`;
            div.style.top = `${y}px`;
            div.style.backgroundColor = color;
            div.textContent = text;
            div.style.display = 'none';
            document.body.appendChild(div);
            return div;
        }

        // 引导页逻辑
        const introModal = document.getElementById('introModal');
        const startBtn = document.getElementById('startBtn');
        startBtn.addEventListener('click', () => {
            introModal.style.display = 'none';
            initHeartWindows();
        });

        // 初始化密集爱心弹窗
        let allWindows = [];
        function initHeartWindows() {
            const screenW = window.innerWidth;
            const screenH = window.innerHeight;
            const winW = 120; // 缩小后的弹窗宽度
            const winH = 36;  // 缩小后的弹窗高度

            // 关键：缩小爱心缩放比例，让弹窗更紧凑
            const scaleX = (screenW - winW - 30) / (16 * 2); // 原60，缩小50%
            const scaleY = (screenH - winH - 60) / (17 + 13); // 原120，缩小50%
            const scale = Math.max(6, Math.min(scaleX, scaleY)); // 原10，降低最小缩放值
            const centerX = screenW / 2;
            const centerY = screenH / 2 - 60; // 原120，同步上移，让爱心位置更居中

            // 生成更多顶点，创建更密集的弹窗
            const heartPoints = getHeartPoints(CONFIG.HEART_COUNT);
            heartPoints.forEach((point, idx) => {
                // 计算弹窗位置，偏移更小，更贴近爱心轮廓
                let px = centerX + point.x * scale - winW / 2 + jitter();
                let py = centerY - point.y * scale - winH / 2 + jitter();
                // 缩小边距，让弹窗更贴近屏幕边缘
                px = Math.max(CONFIG.MARGIN, Math.min(px, screenW - winW - CONFIG.MARGIN));
                py = Math.max(CONFIG.MARGIN, Math.min(py, screenH - winH - CONFIG.MARGIN));

                // 更快的间隔显示弹窗，营造密集感
                const color = randomPastelHex();
                const text = CONFIG.MESSAGES[Math.floor(Math.random() * CONFIG.MESSAGES.length)];
                const tipWin = createTipWindow(px, py, color, text);
                setTimeout(() => {
                    tipWin.style.display = 'flex';
                }, idx * CONFIG.POP_INTERVAL_MS);

                allWindows.push({
                    elem: tipWin,
                    initX: px,
                    initY: py
                });
            });

            // 调整总显示时间，匹配更快的弹窗生成速度
            const totalShowMs = CONFIG.HEART_COUNT * CONFIG.POP_INTERVAL_MS + 400; // 原600，缩短33%
            setTimeout(animateGather, totalShowMs);
        }

        // 弹窗收拢动画（保持流畅，适配密集弹窗）
        function animateGather(step = 0) {
            const screenW = window.innerWidth;
            const screenH = window.innerHeight;
            const winW = 120;
            const winH = 36;
            const gatherX = screenW / 2 - winW / 2;
            const gatherY = screenH / 2 - winH / 2;

            if (step < CONFIG.GATHER_STEPS) {
                const t = step / CONFIG.GATHER_STEPS;
                allWindows.forEach(item => {
                    const currentX = lerp(item.initX, gatherX, t);
                    const currentY = lerp(item.initY, gatherY, t);
                    item.elem.style.left = `${currentX}px`;
                    item.elem.style.top = `${currentY}px`;
                });
                setTimeout(() => animateGather(step + 1), CONFIG.GATHER_INTERVAL_MS);
            } else {
                setTimeout(startExplode, 200);
            }
        }

        // 满屏密集弹窗
        function startExplode() {
            const screenW = window.innerWidth;
            const screenH = window.innerHeight;
            const winW = 120;
            const winH = 36;

            // 销毁原爱心弹窗
            allWindows.forEach(item => {
                item.elem.remove();
            });
            allWindows = [];

            // 增加满屏弹窗数量，保持密度一致
            let targetTiles = CONFIG.EXPLODE_COUNT;
            if (targetTiles <= 0) {
                const cols = Math.max(1, Math.floor(screenW / winW));
                const rows = Math.max(1, Math.floor(screenH / winH));
                const totalCells = cols * rows;
                targetTiles = Math.min(800, Math.max(CONFIG.HEART_COUNT, Math.floor(totalCells * 0.95))); // 覆盖率提至95%
            }
            targetTiles = Math.min(targetTiles, 800); // 提升最大弹窗数

            // 缩小弹窗间距，增加密度
            function generatePositions(n) {
                const positions = [];
                const baseDx = winW * 0.45; // 原0.65，缩小31%，减少间距
                const baseDy = winH * 0.45 * 0.8;
                let attempts = 0;
                const maxAttempts = n * 150; // 增加尝试次数，确保生成足够位置

                while (positions.length < n && attempts < maxAttempts) {
                    const x = Math.floor(Math.random() * (screenW - winW - 2 * CONFIG.MARGIN)) + CONFIG.MARGIN;
                    const y = Math.floor(Math.random() * (screenH - winH - 2 * CONFIG.MARGIN)) + CONFIG.MARGIN;
                    const isOverlap = positions.some(pos => {
                        const cx1 = pos.x + winW / 2;
                        const cy1 = pos.y + winH / 2;
                        const cx2 = x + winW / 2;
                        const cy2 = y + winH / 2;
                        const dx = Math.abs(cx1 - cx2);
                        const dy = Math.abs(cy1 - cy2);
                        const thx = Math.random() * (baseDx * 1.1 - baseDx * 0.5) + baseDx * 0.5; // 缩小阈值
                        const thy = Math.random() * (baseDy * 1.1 - baseDy * 0.5) + baseDy * 0.5;
                        return dx < thx && dy < thy;
                    });
                    if (!isOverlap) {
                        positions.push({ x, y });
                    }
                    attempts++;
                }

                // 补充位置，确保数量足够
                while (positions.length < n) {
                    const x = Math.floor(Math.random() * (screenW - winW - 2 * CONFIG.MARGIN)) + CONFIG.MARGIN;
                    const y = Math.floor(Math.random() * (screenH - winH - 2 * CONFIG.MARGIN)) + CONFIG.MARGIN;
                    positions.push({ x, y });
                }
                return positions;
            }

            // 生成并显示满屏密集弹窗
            const scatterPositions = generatePositions(targetTiles);
            scatterPositions.forEach((pos, idx) => {
                const color = randomPastelHex();
                const text = CONFIG.MESSAGES[Math.floor(Math.random() * CONFIG.MESSAGES.length)];
                const tipWin = createTipWindow(pos.x, pos.y, color, text);
                setTimeout(() => {
                    tipWin.style.display = 'flex';
                }, idx * CONFIG.EXPLODE_INTERVAL_MS);
                allWindows.push({ elem: tipWin });
            });
        }

        // ESC键关闭重置
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                allWindows.forEach(item => {
                    item.elem.remove();
                });
                allWindows = [];
                introModal.style.display = 'flex';
            }
        });
    </script>
</body>
</html>